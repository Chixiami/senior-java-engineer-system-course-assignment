# **题目 01**
**请你用自己的语言介绍 Java 运行时数据区（内存区域）**

* 堆、虚拟机栈、本地方法栈、方法区（永久代、元空间）、运行时常量池（字符串常量池）、直接内存

  **堆：**是JVM启动时创造的内存区域，放置对象、数组和运行时常量，垃圾回收主要是针对堆进行处理。

  **虚拟机栈：**属于线程的空间，与线程的生命周期相同，方法在执行时会创建栈帧。栈内存大小决定方法调用的深度。

  **本地方法栈：**native方法使用本地方法栈，其他与虚拟机栈类似

  **方法区:**主要包含Class，运行时常量池（字符串常量池jdk1.7之后转移到堆）和jit编译器编译之后的代码缓存。

  jdk1.8之前方法区使用永久代进行实现，永久代使用JVM进程所使用的区域，大小收到JVM大小的限制。

  jdk1.8以及之后方法去使用元空间进行实现，元空间位置是在物理内存区域，与JVM大小无关，只物理内存限制，并且静态变量与字符串常量池移动到了堆中。

  之所以jdk1.8将永久代换为了元空间主要原因如下：

  1. 因为永久区收到JVM大小限制，字符串放在永久区中容易导致永久代的内存溢出。

  2. 类和方法信息比较难以确定大小，永久区的大小定义困难

  3. 永久代GC效率低，并且比较复杂

  4. oracle要将HotSpot与JRockit合并，JRockit中没有永久代

**字符串常量池**：jdk1.7以及之后放置在堆中，包含用双引号括起来的字符串常量值，其中数据使用哈希表的方式进行存储

**直接内存：**在jdk1.4中引入NIO类，可以分配直接内存，相比堆内存，申请耗费更大，但是IO的读写性能更好，适合数据大，生命周期长的情况以及IO频繁的情况

* 为什么堆内存要分年轻代和老年代？

主要基于两个假说，弱分代假说和强分代假说

弱分代假说：大部分对象都是朝生夕灭的。

强分代假说：熬过越多次垃圾收集的对象就越难消亡

所以根据这两个假说，将堆内存区域分为年轻代和老年代，针对年轻代，只需要关注要保留下来的对象，节省空间，针对老年代，回收的频次可以较低，节省时间，这样可以兼顾时间和空间的利用。

# **题目 02**

描述一个java对象的生命周期

1. **创建过程：**

   new 指令之后先进行常量池检查，看常量池中是否有这个类的符号引用，如果没有的话，就加载这个类，如果有的话，再去看这个类是否被加载，如果未加载，则加载类，如果已经加载，就开始分配内存空间

2. **内存分配：**

   不同GC垃圾收集器内存分配方式不同，分为指针碰撞和空闲列表

   新对象申请后先看eden区是否能放得下，如果放不下，则进行YGC后再判断，如果放得下则进入年轻代，如果放不下判断老年代是否能放得下，如果放不下则进行FGC之后再判断，放得下进入老年代，如果还是放不下则OOM

   新生代

3. **销毁过程：**

   根据根可达算法进行分析之后，没有应用链的对象会被第一次标记，被标记之后再进行一次筛选，看是否有必要执行finalize()方法，方法中没有重新与引用链建立关联关系的，会被第二次标记，第二次标记成功对象会被回收，失败会继续存活。

4. **对象的两种访问方式：**

   1. 句柄：通过栈中的reference到句柄池中通过到对象实例实例的指针访问到对象，优点是对象移动时只是改变句柄中的指针，reference不变化，比较稳定
   2. 直接指针：通过栈中的reference直接关联到对象实例的指针访问到对象，优点是少了一次指针定位，访问快

5. **为什么需要内存担保：**新生代内存不够的时候，需要把新生代eden区的GC之后还存活的对象放到老年代，从而eden区腾出空间放新的对象

# **题目 03**
垃圾收集算法有哪些？垃圾收集器有哪些？他们的特点是什么？

* 垃圾收集算法：
  1. **标记-清除算法：** 有两个阶段，标记和清除，标记阶段标出所有要回收的对象，清除阶段统一进行回收。缺点是执行效率不稳定和会产生内存碎片。

  2. **复制算法：** 内存分为两块，将清除后存活的对象复制到另一块。优点是没有内存碎片，缺点是有空间浪费
  3. **标记-整理算法：** 在标记和清除之后，多了一个整理的步骤，将剩余存活的对象统一移动到另一端 优点是没有内存碎片，缺点是效率低
  垃圾收集器：
* 垃圾收集器：
1. **ParNew:** 新生代并行,是serial的多线程版版本，老年代串行serialold

2. **ParallelScavenge:** 新生代并行，用复制算法，吞吐量优先，老年代串行

   1. **ParallelOld:**parallelscavenge的老年版本，标记-整理算法，多线程

3. **CMS:**使用标记清除算法， 分为四个阶段：

   1. 初始标记：会STW，标记处gcroots关联到的对象

   2. 并发标记：不是STW，从gcroots关联的对象遍历对象图

   3. 重新标记：会STW，修正并发期间新产生的对象记录

   4. 并发清除：不会STW，清除判断死亡的对象

      优点：低延迟，减少stw对用户影响，并发收集，堆内存到了一定阈值开始回收

      缺点：会产生内存碎片，内存碎片会导致并发清除后用户线程可用空间不足

      ​			对CPU资源敏感

4. **G1 :** 全局标记-整理，局部复制算法

   1. 初始标记：会STW 标记gcroots关联到的对象

   2. 并发标记：不会STW 从gcroots关联对象遍历对象图

   3. 最终标记：会STW 修正并发期间新产生的对象记录

   4. 筛选回收： 会STW，根据region的回收价值和成本排序，根据期望GC停顿时间确定回收计划

      优点：支持并发，多代收集，整堆进行回收，由于使用标记-整理和复制算法，不会有内存碎片，可以指定GC停顿时间

      缺点：GC时间短的话回收空间的效率会降低