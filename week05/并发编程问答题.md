# 题目 01- 请你说一说什么是线程和进程？
* 区别
* 关系
* 线程的上下文切换是什么？
* 线程的并发与并行有啥区别？

**进程：** 是操作系统分配资源的基本单位，是在内存中运行的程序的一次执行过程。

**线程：** 是处理器任务调度与执行的基本单位，负责当前进程中任务的执行。

**线程和进程的区别**： 
1. 线程的上下文切换消耗小于进程的上下文切换消耗。
2. 进程与进程之前的内存空间是独立的，同一个进程的线程之间堆空间和方法区共享，栈空间和程序计数器独立。

**线程和进程的关系**：

一个线程只能属于一个进程，而一个进程可以有多个线程

**线程的上下文切换：** 由于一个CPU同一时刻只能被一个线程使用，为了提升效率CPU采用时间片算法将CPU时间片轮流分配给多个线
程。在分配的时间片内线程执行，如果没有执行完毕，则需要挂起然后把CPU让给其他线程。
CPU在切换线程的时候，会记录当前线程的执行位置在程序计数器中，用来在下次执行的时候找到准确的位置，线程执行位置的记录与加载的过程叫做线程的上下文切换。
# 题目02-使用了多线程会带来什么问题呢？
* 详细描述线程安全问题：

多个线程同时执行，如果多线程运行结果与单线程运行结果一致，变量的预期值相同，则为线程安全，否则为线程不安全。

造成线程安全问题的原因是多个线程同时对共享变量进行写与读。

java中解决线程安全问题的方法有：
1. 同步机制 Synchronized。
2. Volatile关键字：内存屏障。
3. 原子类 CAS。
4. 锁 AQS。
5. 并发容器。


* 详细描述原子性、有序性和可见性：
1. 原子性：一个系列，要么全执行，要么全不执行，执行过程不能被打断。
2. 有序性：程序代码按照先后顺序执行。
3. 可见性：当多个线程访问同一个变量时，一个线程修改了共享变量的值，其他线程能够立即看到。

# 题目03-什么是死锁？如何排查死锁?
当线程A持有独占锁a，并尝试去获取独占锁b的同时，线程B持有独占锁b，并尝试获取独占锁a的情况下，就会发生AB两个线程由于互相持有对方需要的锁，而发生的阻塞现象，称之为死锁。

排查死锁可以使用 jps查看java进程，再通过jstack -l 进程编号 在输出日志中可以查看是否有死锁以及各个线程对于锁的持有情况。

# 题目04-请你说一说synchronized和volatile的原理与区别
* 什么是JMM内存模型?

* 什么是happens-before规则?

**Synchronized实现原理：**

jdk1.6之前：依赖于OS底层互斥锁的MutexLock，存在严重的性能问题。
jdk1.6之后：实现方式为Monitor（管程）。

**volatile实现原理：**

实现内存可见性的原理是内存屏障，Volatile变量写操作时，在写操作后加一条store屏障指令，让本地内存中变量的值能够刷新到主内存，Volatile变量读操作时，在读操作前加一条load屏障指令，及时读取到变量在主内存的值。

**Synchronized与volatile区别：**
1. Synchronized会阻塞线程，votatile不会阻塞线程。
2. volatile只能作用在变量级别，Synchronized可以作用在变量、方法和类的级别。
3. volatile只能保证可见性，不能保证原子性，Synchronized可以保证可见性和原子性。
4. volatile的性能要好于Synchronized。

**JMM内存模型：**
JMM就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种
平台下对内存的访问都能保证效果一致的机制及规范。

**happens-before规则:**
是JMM中保障内存可见性的方案，用来约束编译器的优化行为，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before的关系，在实现上是处理器重排序规则和编译器重排序规则。


# 题目05-为什么使用线程池？如何创建线程池？
**使用线程池原因：**
1. 降低资源消耗，线程池可以复用线程，降低线程创建和销毁的开销
2. 提高响应速度，任务到达时不用等待
3. 提高线程的可管理性，使用线程池可以对线程统一分片，调优和监控
4. 具有可扩展性，可以在线程池中加入延时、定时、监控等功能

**如何创建线程池：**
1. 自动创建线程池：
    * newFixedThreadPool：固定数量线程池，无界任务阻塞队列
    * newSingleThreadExecutor ：一个线程线程的线程池，无界任务阻塞队列
    * newCachedThreadPool ：可缓存线程的无界线程池，可以自动回收多余线程
    * newScheduledThreadPool ：定时任务线程池
2. 手动创建线程池：
    * 使用标准构造器 ThreadPoolExecutor 创建，配置线程池参数，线程名以及拒绝策略 

**线程池实现原理：**
先判断核心线程池 corePoolSize 是否满了，如果没满，就创建一个新的线程执行任务，如果满了，判断队列是否满了，如果队列没满，则把任务添加到队列，如果队列满了，判断是否小于最大线程数，如果小于最大线程数，就创建一个非核心线程来执行任务，如果大于等于最大线程数，则拒绝该任务
    
# 题目06-ThreadLocal中Map的key为什么要使用弱引用？
线程在执行完方法后，方法的栈帧会被销毁，但是线程的 ThreadLocalMap 里的对应的 Entry 的 Key 引用还指ThreadLocal 实例,如果是强引用的话， Key 引用指向的 ThreadLocal 实例、及其 Value 值都不能被 GC回收，这将造成严重的内存泄露。

如果是弱引用的话， ThreadLocal 实例在下次GC时会被回收， Entry的 Key 引用被回收之后，其 Entry 的 Key 值变为 null，后续当 ThreadLocal 的 get、 set 或 remove 被调用时，通过expungeStaleEntry方法， ThreadLocalMap 的内部代码会清除这些 Key 为 null 的 Entry，从而完成相应的内存释放。
* 阿里 Java 开发手册中，为什么说不清理自定义的 ThreadLocal 变量会导致内存泄露呢:

在线程池场景下，线程会被复用，使得ThreadLocal 不会被释放，会造成内存泄露，所以需要进行主动删除